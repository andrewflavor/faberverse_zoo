<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My Zoo</title>

    <style>
      html, body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #000;
      }
      #ui {
        position: fixed;
        left: 12px;
        top: 12px;
        color: white;
        font-family: system-ui, sans-serif;
        background: rgba(0,0,0,0.5);
        padding: 12px 14px;
        border-radius: 12px;
        max-width: 360px;
        line-height: 1.35;
      }
      #btn {
        margin-top: 10px;
        padding: 8px 12px;
        border-radius: 10px;
        border: 0;
        font-size: 16px;
        cursor: pointer;
      }
      #small {
        opacity: 0.9;
        font-size: 13px;
        margin-top: 6px;
      }
    </style>

    <!-- Import map -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
    </script>
  </head>

  <body>
    <div id="ui">
      <b>My Zoo</b><br />
      Click <b>Start</b> then use <b>WASD</b> + mouse to look.<br />
      <b>Esc</b> releases mouse.
      <div id="small">
        Tip: If walking feels slow/fast, change <code>WALK_SPEED</code> below.
      </div>
      <button id="btn">Start</button>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

      // ===== Tunables =====
      const EYE_HEIGHT = 1.7;          // “human” camera height
      const WALK_SPEED = 10;           // units/second (increase if world feels big)
      const HEIGHT_SMOOTH = 0.25;      // 0..1 (higher = snappier to ground)
      const RAY_START_ABOVE = 100;     // how far above we cast from
      const RAY_MAX_DISTANCE = 500;    // how far down we search for ground
      const WORLD_FORWARD_NUDGE = 0.0; // keep 0 unless you want to offset world

      // Scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      // Camera
      const camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        5000
      );
      camera.position.set(0, 5, 15);

      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.85));
      const sun = new THREE.DirectionalLight(0xffffff, 0.85);
      sun.position.set(50, 80, 30);
      scene.add(sun);

      // Controls
      const controls = new PointerLockControls(camera, document.body);
      document.getElementById("btn").onclick = () => controls.lock();
      controls.addEventListener("lock", () => (document.getElementById("ui").style.display = "none"));
      controls.addEventListener("unlock", () => (document.getElementById("ui").style.display = "block"));

      // Ground + Animal collision helpers (simple + mobile-friendly)
      const raycaster = new THREE.Raycaster();
      const DOWN = new THREE.Vector3(0, -1, 0);

      // Walkable surfaces (volcano/terrain/etc.)
      let groundMeshes = [];
      // Animals you should not walk through
      let animalMeshes = [];

      // If your GLB object names include these words, we'll auto-detect them.
      // Tip: rename in Blender to make this perfect (e.g. VOLCANO_GROUND, ELEPHANT_ANIMAL).
      const GROUND_NAME_HINTS = ["ground", "terrain", "volcano", "mountain", "path", "rock", "floor"];
      const ANIMAL_NAME_HINTS = ["animal", "elephant", "giraffe", "zebra", "lion", "tiger", "bear", "monkey", "penguin", "hippo", "rhino"];

      const GROUND_NORMAL_MIN_Y = 0.25; // ignore walls/undersides (0.0 = any, 1.0 = perfectly up)
      const MAX_STEP_UP = 0.8;          // prevent snapping up huge cliffs in one frame

      function looksLikeAnimal(obj) {
        const n = (obj.name || "").toLowerCase();
        if (obj.isSkinnedMesh) return true; // skinned meshes are almost always characters/animals
        return ANIMAL_NAME_HINTS.some((k) => n.includes(k));
      }

      function looksLikeGround(obj) {
        const n = (obj.name || "").toLowerCase();
        return GROUND_NAME_HINTS.some((k) => n.includes(k));
      }

      function buildCollisionLists(root) {
        groundMeshes = [];
        animalMeshes = [];

        root.traverse((obj) => {
          if (!obj.isMesh) return;

          // Keep raycasting accurate
          obj.frustumCulled = true;

          // Classify: animals vs ground. If we can't tell, default to ground.
          if (looksLikeAnimal(obj)) {
            animalMeshes.push(obj);
          } else if (looksLikeGround(obj)) {
            groundMeshes.push(obj);
          } else {
            groundMeshes.push(obj);
          }
        });

        // If everything got classified as ground (common if nothing is named),
        // it's still fine — animals won't be blocked unless they are SkinnedMesh or named like an animal.
        console.log("Collision lists:", { ground: groundMeshes.length, animals: animalMeshes.length });
      }

      function setGroundedHeight() {
        if (!groundMeshes.length) return;

        const origin = camera.position.clone();
        origin.y += RAY_START_ABOVE;

        raycaster.far = RAY_START_ABOVE + RAY_MAX_DISTANCE;
        raycaster.set(origin, DOWN);

        const hits = raycaster.intersectObjects(groundMeshes, true);
        if (!hits.length) return;

        // Pick the first "walkable" face (normal points upward-ish).
        // If face normals are missing for any reason, fall back to the closest hit.
        const hit =
          hits.find((h) => h.face && h.face.normal && h.face.normal.y > GROUND_NORMAL_MIN_Y) || hits[0];

        const groundY = hit.point.y;
        const targetY = groundY + EYE_HEIGHT;
        const delta = targetY - camera.position.y;

        // Don't teleport up huge steps
        if (delta > MAX_STEP_UP) return;

        camera.position.y = THREE.MathUtils.lerp(camera.position.y, targetY, HEIGHT_SMOOTH);
      }

      function blockAgainstAnimals() {
        if (!animalMeshes.length) return;

        // Treat each animal like a circle on the XZ plane (cheap + works great).
        const animalPos = new THREE.Vector3();
        const scale = new THREE.Vector3();

        for (const a of animalMeshes) {
          // Cache a radius for this mesh (bounding sphere * scale)
          if (!a.userData.blockRadius) {
            if (a.geometry && !a.geometry.boundingSphere) a.geometry.computeBoundingSphere();
            a.getWorldScale(scale);
            const maxScale = Math.max(scale.x, scale.y, scale.z);
            const base = a.geometry?.boundingSphere?.radius ?? 1.0;
            a.userData.blockRadius = base * maxScale * 0.9;
          }

          a.getWorldPosition(animalPos);

          const r = a.userData.blockRadius;
          const dx = camera.position.x - animalPos.x;
          const dz = camera.position.z - animalPos.z;
          const dist = Math.hypot(dx, dz);

          if (dist < r && dist > 0.0001) {
            const push = r - dist;
            camera.position.x += (dx / dist) * push;
            camera.position.z += (dz / dist) * push;
          }
        }
      }

      // Load terrain
      const loader = new GLTFLoader();
      loader.load(
        "./zoo_terrain.glb",
        (gltf) => {
          const world = gltf.scene;
          worldRoot = world;
          scene.add(world);

          // Build collision lists (ground vs animals)
          buildCollisionLists(world);

          // Auto-center model at origin (so camera + movement are sane)
          const box = new THREE.Box3().setFromObject(world);
          const center = box.getCenter(new THREE.Vector3());
          world.position.sub(center);
          world.position.z += WORLD_FORWARD_NUDGE;

          // Recompute box after centering
          const box2 = new THREE.Box3().setFromObject(world);
          const size = box2.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);

          // Start closer than before
          camera.position.set(0, maxDim * 0.25 + 5, maxDim * 0.45 + 8);
          camera.lookAt(0, 0, 0);

          // Snap to ground once so you don’t start underground/too high
          setGroundedHeight();

          console.log("Terrain loaded. size:", size);
        },
        undefined,
        (err) => console.error(err)
      );

      // Movement keys
      const keys = {};
      window.addEventListener("keydown", (e) => (keys[e.code] = true));
      window.addEventListener("keyup", (e) => (keys[e.code] = false));

      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.05);

        if (controls.isLocked) {
          // Move on XZ plane only
          const forward = new THREE.Vector3();
          camera.getWorldDirection(forward);
          forward.y = 0;
          forward.normalize();

          const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize().multiplyScalar(-1);

          const move = new THREE.Vector3();
          if (keys["KeyW"]) move.add(forward);
          if (keys["KeyS"]) move.sub(forward);
          if (keys["KeyD"]) move.add(right);
          if (keys["KeyA"]) move.sub(right);

          if (move.lengthSq() > 0) {
            move.normalize();
            camera.position.addScaledVector(move, WALK_SPEED * dt);
          }

          // Don't walk through animals (simple blockers)
          blockAgainstAnimals();

          // Ground follow keeps you on top of the terrain/volcano
          setGroundedHeight();
        }

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
